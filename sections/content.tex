%% LaTeX2e class for student theses
%% sections/content.tex
%% 
%% Karlsruhe Institute of Technology
%% Institute of Information Security and Dependability
%% Software Design and Quality (SDQ)
%%
%% Dr.-Ing. Erik Burger
%% burger@kit.edu
%%
%% Version 1.5, 2024-02-12

\chapter{The QEMU API}
As the goal of this paper is to extract data without having to change code of QEMU,
it is neccessary to take a look at the data QEMU offers by itself.
QEMU offers 3 kinds of semi-external APIs: The QEMU Human Monitor (QHM),
the QEMU Machine Protocol (QMP) and so-called "Internal QEMU APIs"\cite{internal}.

As the name suggests, the internal QEMU APIs are not useful for external use by themselves.
Instead, they can be used when modifying QEMU-code and then extracting data by the means of GDB or directly by the QEMU process.
As the goal is to use any standard QEMU implementation, these internal APIs will not be regarded further in this paper.

In the two following sections, both QMP and QHM are further explored. Both the basic functionality,
as well as the commands used for this paper get explained in detail.
Also the differences of both protocols, especially in regards to their capabilities,
get discussed.

\section{QEMU Machine Protocol (QMP)} \label{sec:QMP}
\enquote{The QEMU Machine Protocol (QMP) is a JSON-based protocol which allows applications to control a QEMU instance}\cite{qmp-description}, as described by the QEMU-Wiki itself.
The protocol was merged into the main branch of QEMU in version 0.13 in 2010, however to this day its status remains as "experimental"\cite{qmp-merge}.
The goal was, and still is, to provide the same data QHM provides, but in a format more accessible for machines.
However, this process is far from complete. To give an example, the patch to add the ability of reading Register contents was only introduced in 2021,
but to this day it wasn't merged into the mainline branch.
Also, this patch doesn't actually provide a valid JSON-object, but just passes the return of the QHM-command "info registers" into the "result"-string\cite{qmp-registers-patch}.\todonote{Probably needs more detail}

This makes QMP the preferred protocol, as the data is in an easily parseable format, which makes extraction very easy.
Also the returned data is generally consistent across architectures, and the documentation is very detailed.
But, as mentioned, QMP is the less powerful protocol when used by itself.
This however directly leads to the most important command\cite{qmp-commands}:

\paragraph{human-monitor-command}
This command is perhaps the most important one in all of this, as it allows to execute QHM-commands in a QMP-environment.
The QEMU reference explicitly marks this command as a \enquote{stop-gap} until all QHM-commands have their counterpart in QMP,
but, as mentioned before, that is not a priority at the moment.
Still, it's currently the only way to access certain data like register contents, even if in an ugly fashion.\todonote{Maybe rephrase this}
Further details on how this command is used are described later on in \autoref{sec:QHM}.

\paragraph{qmp\_capabilities}
This command must be sent at the beginning of any QMP session to activate the session.
On an unmodified QEMU instance, it returns an empty JSON-object.
The command is intended to show the client additional features of a modified QEMU-instance,
however in this paper this command serves no purpose except unlocking QMP.

\paragraph{query-cpus-fast}
Gives information about all available CPUs, namely their architecture,
their count, and the ID of the host thread simulating the CPU.
The commmand is a replacement for \emph{query-cpus}, which was removed and returned slightly different data.
The main purpose for this paper is to get the CPU count, as registers need to be queried individually for each CPU.

\paragraph{query-block}
Queries for all kinds of drives. Gives information about attached storage mediums and where their content is stored.
This of course gets used to back up the neccessary files later on.
Also shows empty devices like optical drives which currently don't contain any media.

\paragraph{stop}
Suspends the emulation of the current system. Is neccessary to keep the data extracted consistent.

\paragraph{cont}
Continues execution of the emulated system after data was extracted.

\section{QEMU Human Monitor (QHM)} \label{sec:QHM}
The QEMU Human Monitor, sometimes referred to as only the QEMU Monitor,
is an interface to send commands to and query data from a running QEMU instance in a human readable form.
This however often leads to inconsistent representation, as there is no clear standard on how to represent data.
Even within single commands, the format may vary wildly across different architectures or even within the same architecture.
At the same time, documentation of commands is very lacking, sometimes consisting of only a single sentence.
This makes detailed exploration into their workings neccessary, and the results of this research are presented in the following\cite{qhm-documentation}:

\subsection{info mem}
\blindtext

\subsection{info mtree}
\blindtext

\subsection{info tlb}
"info tlb" gets described as "Show virtual to physical memory mappings"\cite{qhm-documentation}.
There seems to be no further documentation as to what this command does or the format of the output.
Finding more information about the supposed TLB is also rather difficult.
Most information is therefore derived from the \citetitle{intel-manual},
which therefore only applies to x86 and makes the portability of any information rather questionable.

An example of the output is provided below:

\begin{ffcode}
    0000000000010000: 00000000001a0000 ---DA---W
    0000000000011000: 0000000000181000 ---DA---W
    0000000000012000: 0000000000182000 ---DA---W
    0000000000013000: 0000000000183000 ---DA---W
    0000000000014000: 0000000000184000 ---DA---W
    0000000000015000: 0000000000185000 ----A---W
    0000000000016000: 0000000000186000 ---DA----
    0000000000017000: 0000000000187000 ----A---W
    0000000000018000: 0000000000188000 ----A----
    0000000000019000: 0000000000189000 ----A----
    000000000001a000: 000000000016a000 ----A----
\end{ffcode}

These are the first eleven lines this command outputs the XBox emulator "xemu"\cite{xemu}.
The output consists of the linear address shown to the guest OS, the "physical" address, which represents the offset in QEMU's emulated memory region,
and the flags associated with each segment.
As the flags are x86-specific, they are currently not of further interest and just get stored without further processing.

It is important to note the physical address is not the actual address in the QEMU-process, but the offset from the base address of said memory region.
To correctly extract the guest RAM, one would now need to find the base address of the memory region the QEMU-process uses to emulate RAM,
and then combine it with the virtual address translation to store memory in the format the guest OS sees it.
This throws up the question in which format the RAM should be stored. In the order it is actually on the hardware, meaning the physical addresses,
or in the order the guest OS sees it, meaning the virtual addresses.