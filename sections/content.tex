%% LaTeX2e class for student theses
%% sections/content.tex
%% 
%% Karlsruhe Institute of Technology
%% Institute of Information Security and Dependability
%% Software Design and Quality (SDQ)
%%
%% Dr.-Ing. Erik Burger
%% burger@kit.edu
%%
%% Version 1.5, 2024-02-12

\chapter{The QEMU API}
As the goal of this paper is to extract data without having to change code of QEMU,
it is neccessary to take a look at the data QEMU offers by itself.
QEMU offers 3 kinds of semi-external APIs: The QEMU Human Monitor (QHM),
the QEMU Machine Protocol (QMP) and so-called "Internal QEMU APIs"\cite{internal}.

As the name suggests, the internal QEMU APIs are not useful for external use by themselves.
Instead, they can be used when modifying QEMU-code and then extracting data by the means of GDB or directly by the QEMU process.
As the goal is to use any standard QEMU implementation, these internal APIs will not be regarded further in this paper.

In the two following sections, both QMP and QHM are further explored. Both the basic functionality,
as well as the commands used for this paper get explained in detail.
Also the differences of both protocols, especially in regards to their capabilities,
get discussed.

\section{QEMU Machine Protocol (QMP)} \label{sec:QMP}
\enquote{The QEMU Machine Protocol (QMP) is a JSON-based protocol which allows applications to control a QEMU instance}\cite{qmp-description}, as described by the QEMU-Wiki itself.
The protocol was merged into the main branch of QEMU in version 0.13 in 2010, however to this day its status remains as "experimental"\cite{qmp-merge}.
The goal was, and still is, to provide the same data QHM provides, but in a format more accessible for machines.
However, this process is far from complete. To give an example, the patch to add the ability of reading Register contents was only introduced in 2021,
but to this day it wasn't merged into the mainline branch.
Also, this patch doesn't actually provide a valid JSON-object, but just passes the return of the QHM-command "info registers" into the "result"-string\cite{qmp-registers-patch}.\todonote{Probably needs more detail}

This makes QMP the preferred protocol, as the data is in an easily parseable format, which makes extraction very easy.
Also the returned data is generally consistent across architectures, and the documentation is very detailed.
But, as mentioned, QMP is the less powerful protocol when used by itself.
This however directly leads to the most important command\cite{qmp-commands}:

\paragraph{human-monitor-command}
This command is perhaps the most important one in all of this, as it allows to execute QHM-commands in a QMP-environment.
The QEMU reference explicitly marks this command as a \enquote{stop-gap} until all QHM-commands have their counterpart in QMP,
but, as mentioned before, that is not a priority at the moment.
Still, it's currently the only way to access certain data like register contents, even if in an ugly fashion.\todonote{Maybe rephrase this}
Further details on how this command is used are described later on in \autoref{sec:QHM}.

\paragraph{qmp\_capabilities}
This command must be sent at the beginning of any QMP session to activate the session.
On an unmodified QEMU instance, it returns an empty JSON-object.
The command is intended to show the client additional features of a modified QEMU-instance,
however in this paper this command serves no purpose except unlocking QMP.

\paragraph{query-cpus-fast}
Gives information about all available CPUs, namely their architecture,
their count, and the ID of the host thread simulating the CPU.
The commmand is a replacement for \emph{query-cpus}, which was removed and returned slightly different data.
The main purpose for this paper is to get the CPU count, as registers need to be queried individually for each CPU.

\paragraph{query-block}
Queries for all kinds of drives. Gives information about attached storage mediums and where their content is stored.
This of course gets used to back up the neccessary files later on.
Also shows empty devices like optical drives which currently don't contain any media.

\paragraph{dump-guest-memory}
This command dumps the contents of the guests memory to disk.
The command itself offers many options, however most of these don't work.
In the used implementation, the only output format working is ELF, and paging is only possible on x86 guests.
Still, it's the only straigforward option to access the guest memory.

\paragraph{stop}
Suspends the emulation of the current system. Is neccessary to keep the data extracted consistent.

\paragraph{cont}
Continues execution of the emulated system after data was extracted.

\section{QEMU Human Monitor (QHM)} \label{sec:QHM}
The QEMU Human Monitor, sometimes referred to as only the QEMU Monitor,
is an interface to send commands to and query data from a running QEMU instance in a human readable form.
This however often leads to inconsistent representation, as there is no clear standard on how to represent data.
Even within single commands, the format may vary wildly across different architectures or even within the same architecture.
At the same time, documentation of commands is very lacking, sometimes consisting of only a single sentence.
This makes detailed exploration into their workings neccessary, and the results of this research are presented in the following\cite{qhm-documentation}:

\subsection{info tlb}
"info tlb" gets described as "Show virtual to physical memory mappings"\cite{qhm-documentation}.
There seems to be no further documentation as to what this command does or the format of the output.
Finding more information about the supposed TLB is also rather difficult.
Most information is therefore derived from the \citetitle{intel-manual},
which therefore only applies to x86 and makes the portability of any information rather questionable.

An example of the output is provided below:

\begin{ffcode}
    0000000000010000: 00000000001a0000 ---DA---W
    0000000000011000: 0000000000181000 ---DA---W
    0000000000012000: 0000000000182000 ---DA---W
    0000000000013000: 0000000000183000 ---DA---W
    0000000000014000: 0000000000184000 ---DA---W
    0000000000015000: 0000000000185000 ----A---W
    0000000000016000: 0000000000186000 ---DA----
    0000000000017000: 0000000000187000 ----A---W
    0000000000018000: 0000000000188000 ----A----
    0000000000019000: 0000000000189000 ----A----
    000000000001a000: 000000000016a000 ----A----
\end{ffcode}

These are the first eleven lines this command outputs the XBox emulator "xemu"\cite{xemu}.
The output consists of the linear address shown to the guest OS, the "physical" address, which represents the offset in QEMU's emulated memory region,
and the flags associated with each segment.
As the flags are x86-specific, they are currently not of further interest and just get stored without further processing.

It is important to note the physical address is not the actual address in the QEMU-process, but the offset from the base address of said memory region.
To correctly extract the guest RAM, one would now need to find the base address of the memory region the QEMU-process uses to emulate RAM,
and then combine it with the virtual address translation to store memory in the format the guest OS sees it.
This throws up the question in which format the RAM should be stored. In the order it is actually on the hardware, meaning the physical addresses,
or in the order the guest OS sees it, meaning the virtual addresses.

\subsection{info mtree}
This command shows all memory regions which are currently allocated for the guest.
This includes main memory, as well as memory for emulated devices like graphic cards.
These regions are given individual names and are separated by blank lines.
To given an example of an ARM64 guest running on x86:

\begin{ffcode}
    address-space: I/O
    0000000000000000-000000000000ffff (prio 0, i/o): io

  address-space: gpex-root
    0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container

  address-space: virtio-gpu-pci
    0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container

  address-space: cpu-memory-0
  address-space: memory
    0000000000000000-ffffffffffffffff (prio 0, i/o): system
      0000000000000000-0000000003ffffff (prio 0, romd): virt.flash0
      0000000004000000-0000000007ffffff (prio 0, romd): virt.flash1
      0000000008000000-0000000008000fff (prio 0, i/o): gic_dist
      0000000008010000-0000000008011fff (prio 0, i/o): gic_cpu
      0000000008020000-0000000008020fff (prio 0, i/o): gicv2m
      0000000009000000-0000000009000fff (prio 0, i/o): pl011
      0000000009010000-0000000009010fff (prio 0, i/o): pl031
      0000000009020000-0000000009020007 (prio 0, i/o): fwcfg.data
      0000000009020008-0000000009020009 (prio 0, i/o): fwcfg.ctl
      0000000009020010-0000000009020017 (prio 0, i/o): fwcfg.dma
      0000000009070000-0000000009070017 (prio 0, i/o): memhp container
      0000000009080000-0000000009080003 (prio 0, i/o): acpi-ged
      000000000a000000-000000000a0001ff (prio 0, i/o): virtio-mmio
      000000000a000200-000000000a0003ff (prio 0, i/o): virtio-mmio
      000000000a000400-000000000a0005ff (prio 0, i/o): virtio-mmio
      ...
\end{ffcode}

In this example we see memory for basic I/O functionality, the GPEX-host bridge, the emulated GPU and "cpu-memory-0".
cpu-memory-0 is special, as the name suggests this may be memory used to emulate the CPU. That however is not the case.
Not only is it much larger than the registers of a single-core CPU could be, but also it's actually a duplicate.
Further down the output is the following data:

\begin{ffcode}
    memory-region: system
    0000000000000000-ffffffffffffffff (prio 0, i/o): system
      0000000000000000-0000000003ffffff (prio 0, romd): virt.flash0
      0000000004000000-0000000007ffffff (prio 0, romd): virt.flash1
      0000000008000000-0000000008000fff (prio 0, i/o): gic_dist
      0000000008010000-0000000008011fff (prio 0, i/o): gic_cpu
      0000000008020000-0000000008020fff (prio 0, i/o): gicv2m
      0000000009000000-0000000009000fff (prio 0, i/o): pl011
      0000000009010000-0000000009010fff (prio 0, i/o): pl031
      0000000009020000-0000000009020007 (prio 0, i/o): fwcfg.data
      0000000009020008-0000000009020009 (prio 0, i/o): fwcfg.ctl
      0000000009020010-0000000009020017 (prio 0, i/o): fwcfg.dma
      0000000009070000-0000000009070017 (prio 0, i/o): memhp container
      0000000009080000-0000000009080003 (prio 0, i/o): acpi-ged
      000000000a000000-000000000a0001ff (prio 0, i/o): virtio-mmio
      000000000a000200-000000000a0003ff (prio 0, i/o): virtio-mmio
      000000000a000400-000000000a0005ff (prio 0, i/o): virtio-mmio
      ...
\end{ffcode}

This shows that the output above is actually normal system memory accessible to the emulated CPU.
Hence the name "cpu-memory-0", as on multi-socket-systems sometimes not all memory is avaliable to all CPUs.

The size of each memory region is shown by the minimum and maximum address of each region.
As this is a 64bit guest, ffffffffffffffff represents 64bits, which results in a memory size of $2^{64}$Bytes.

Most regions are specialized and the name of the region gives an indication of where to look,
but it isn't actually relevant in most cases.
Because of this, only certain regions will be explained:

\paragraph{virt.flash}
There are 2 regions with this name. \emph{virt.flash0} is the basic EFI, which under aarch64 is not included by default.
\emph{virt.flash1} stores EFI-variables like boot order.
The reason these regions are split is \emph{virt.flash1} is writeable, while \emph{virt.flash0} isn't.
The main reason these are interesting is them being backed by files on disk.
This means any changes made to these regions made by the guest can be easily read externally by opening those files.
Of course that comes with a massive performance penalty if many accesses to such regions are made.